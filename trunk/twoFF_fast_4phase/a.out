/* This file contains all the basic elements required for this project. Each elements are defined in separate modules*/

/* D-Flip Flop*/
module dff(/*AUTOARG*/
   // Outputs
   q, q_bar,
   // Inputs
   d, clk, reset
   );

   parameter DELAY = 1;
   
   input d,clk,reset;
   output q, q_bar;

   reg 	  q_i;
 	  
   /*AUTOREG*/
  
   always @(posedge clk or posedge reset) begin
      if(reset) begin
	 q_i <= 1'b0; //using non blocking assignments for the sequential logic
      end else begin
	 q_i <= d;
      end
   end
  assign #DELAY q = q_i;
  assign #DELAY q_bar = ~q_i;   
endmodule // dff

/*NOT gate*/
module inv(/*AUTOARG*/
   // Outputs
   idash,
   // Inputs
   i
   );

   parameter DELAY = 1;

   output idash;
   input i;

   assign #DELAY idash = !i;   
endmodule // inv

/* 2 input AND gate*/
module and2(/*AUTOARG*/
   // Outputs
   q,
   // Inputs
   a, b
   );

   parameter DELAY = 1;

   output q;
   input  a, b;

   assign #DELAY q = a & b;
endmodule // and2

/* 3 input AND gate*/
module and3(/*AUTOARG*/
   // Outputs
   q,
   // Inputs
   a, b, c
   );

   parameter DELAY = 1;

   output q;
   input  a, b, c;

   assign #DELAY q = a & b & c;
endmodule // and3

/* 2 input OR gate*/
module or2 (/*AUTOARG*/
   // Outputs
   q,
   // Inputs
   a, b
   );

   parameter DELAY = 1;

   output q;
   input  a, b;

   assign #DELAY q = a | b;   
endmodule // or2

/* 2 input nor gate*/
module nor2(/*AUTOARG*/
   // Outputs
   q,
   // Inputs
   a, b
   );
   parameter DELAY = 1;

   output q;
   input  a, b;

   assign #DELAY q = ~ (a | b);
endmodule // nor2

/* 3 input OR gate*/
module or3( /*AUTOARG*/
   // Outputs
   q,
   // Inputs
   a, b, c
   );

   parameter DELAY = 1;

   output q;
   input  a, b, c;

   assign #DEALAY q = a | b | c;
endmodule // or3

/* 2 input EXOR gate*/ 
module xor2(/*AUTOARG*/
   // Outputs
   q,
   // Inputs
   a, b
   );
   
   parameter DELAY = 1;

   output q;
   input  a, b;

   assign #DELAY q = a ^ b;
endmodule // xor2

/* 3 input EXOR gate*/
module xor3(/*AUTOARG*/
   // Outputs
   q,
   // Inputs
   a, b, c
   );

   parameter DELAY = 1;

   output q;
   input  a, b, c;

   assign #DELAY q = a ^ b ^ c;   
endmodule // xor3

/* S-R latch built using NOR gates*/
module srlatch(/*AUTOARG*/
   // Outputs
   q, qbar,
   // Inputs
   s, r
   );

   parameter DELAY = #1;

   output q, qbar;
   input  s, r;

   /*AUTOREG*/
   // Beginning of automatic regs (for this module's undeclared outputs)
   reg			q;
   reg			qbar;
   // End of automatics
   nor2 norx(qbar, s, q);
   nor2 nory(q, r, qbar);   
endmodule // srlatch

   
/* Delay element*/
module delay(/*AUTOARG*/
   // Outputs
   q,
   // Inputs
   i
   );

   parameter DELAY = 1;

   output q;
   input  i;

   assign #DELAY q = i;
endmodule // delay

/* Muller-c element*/
module celement(/*AUTOARG*/
   // Outputs
   q,
   // Inputs
   a, b, reset
   );
   
   parameter DELAY = 1;
   output q;
   input  a, b, reset;

   /*AUTOREG*/
   // Beginning of automatic regs (for this module's undeclared outputs)
   reg			q;
   // End of automatics
   always @(*) begin
      if(reset) begin
	 q <= 0;	 
      end else if(a == b) begin
	 q <= #DELAY b;	 
      end            
   end
endmodule // celement
   
/* Data register with multiple buswidth*/
module regdata(/*AUTOARG*/
   // Outputs
   q,
   // Inputs
   a, clk, reset
   );



/*parameter aw = `address_width-1; // RB :see def.v ...
parameter dw = `data_width-1;
parameter sw = `select_width-1;
parameter data_address = 8'b1111_1111;*/




   parameter DELAY = 1;

   output [DATA_MSB:0] q;
   input [DATA_MSB:0]  a;
   input 	       clk, reset;
   
   reg [DATA_MSB:0]    q_i;    
   
   always @(posedge clk or posedge reset) begin
      if(reset) begin
	 q_i <= 0;
      end else begin
	 q_i <= a;	 
      end      
   end
   assign #DELAY q = q_i;   
endmodule // regdata

/*T-flip flop */
module tff(/*AUTOARG*/
   // Outputs
   q, qbar,
   // Inputs
   t, clk, reset
   );

   parameter DELAY = 1;

   output q, qbar;
   input  t, clk, reset;

   reg 	  q_i;
   
   always@(posedge clk or posedge reset) begin
      if(reset) begin
	 q_i <= 1'b0;	
      end else if(t) begin
	 q_i <= ~q_i;	 
      end      
   end

   assign #DELAY q = q_i;
   assign #DELAY qbar = ~q_i;
endmodule // tff

/* MUX 2:1*/
module mux(/*AUTOARG*/
   // Outputs
   q,
   // Inputs
   a, s
   );

   parameter DELAY = 1;

   output q;
   input [1:0] a;
   input       s;

   assign #DELAY q = s ? a[1] : a[0];
endmodule // mux

/* Data register with multiple buswidth and enable input*/
module regdataen(/*AUTOARG*/
   // Outputs
   q,
   // Inputs
   a, en, reset
   );



/*parameter aw = `address_width-1; // RB :see def.v ...
parameter dw = `data_width-1;
parameter sw = `select_width-1;
parameter data_address = 8'b1111_1111;*/




   parameter DELAY = 1;

   output [DATA_MSB:0] q;
   input [DATA_MSB:0]  a;
   input 	       en, reset;
   
   reg [DATA_MSB:0]    q_i;    
   
   always @(posedge en or posedge reset) begin
      if(reset) begin
	 q_i <= 0;
      end else begin
	 q_i <= a;	 
      end      
   end
   assign #DELAY q = q_i;   
endmodule // regdataen

/* Data register with multiple buswidth and enable + enable* input*/
module regdataenstar(/*AUTOARG*/
   // Outputs
   q,
   // Inputs
   a, en, reset, enstar
   );



/*parameter aw = `address_width-1; // RB :see def.v ...
parameter dw = `data_width-1;
parameter sw = `select_width-1;
parameter data_address = 8'b1111_1111;*/




   parameter DELAY = 1;

   output [DATA_MSB:0] q;
   input [DATA_MSB:0]  a;
   input 	       en, reset, enstar;
   
   reg [DATA_MSB:0]    q_i;    
   
   always @(posedge en or posedge reset or negedge enstar) begin
      if(reset) begin
	 q_i <= 0;
      end else begin
	 q_i <= a;	 
      end      
   end
   assign #DELAY q = q_i;   
endmodule // regdataenstar

/* Register with enable, enable star and async reset */
module regenstar(/*AUTOARG*/
   // Outputs
   q,
   // Inputs
   a, en, reset, enstar
   );
 
   parameter DELAY = 1;

   output q;
   input  a;
   input  en, reset, enstar;
   
   reg q_i;    
   
   always @(posedge en or posedge reset or negedge enstar) begin
      if(reset) begin
	 q_i <= 0;
      end else begin
	 q_i <= a;	 
      end      
   end
   assign #DELAY q = q_i;   
endmodule // regenstar

/* Yet to be done :-) */
/* MUTEX element*/
/* D-Flip flop with Async reset and EN* */
/* Asynchronous Controllers for LDL*/




/*parameter aw = `address_width-1; // RB :see def.v ...
parameter dw = `data_width-1;
parameter sw = `select_width-1;
parameter data_address = 8'b1111_1111;*/



/* This module is the implementation of the Tx-FSM for the fast two flop-4 phase sync(literature : zerolatency.pdf page-4) */
module txfsm(/*AUTOARG*/
   // Outputs
   snt, en,
   // Inputs
   vi, clk, reset, a2p, a2d
   )


   parameter  rst = 2'b00;  // Asynchronous reset state
   parameter  wdata = 2'b01;  // Wait for the input 'v'
   parameter  done = 2'b10; // Data is on the bus, send the request to receiver (this is push synchronizer)
   parameter  wack = 2'b11; // Waiting for the deassertion of ack
   
   reg[1:0]   current_state, next_state;   
   
   output  snt, en;
   input   vi, clk, reset, a2p, a2d;

   /*AUTOREG*/
   // Beginning of automatic regs (for this module's undeclared outputs)
   reg			en;
   reg			snt;
   // End of automatics

/*transmitter state machine*/   
     /* Sequential block*/
    always @(posedge clk or posedge reset) begin        
       if(reset) begin
	  current_state <= rst;
       end else begin
	  current_state <= next_state;
       end
    end

   /* Combinational block*/
   always @(*) begin
      next_state = current_state;
      case(current_state) 
	 rst: begin
	    next_state = wdata;
	    en = 1'b0;
	    snt = 1'b0;	    
	 end

	 wdata: begin
	    if(vi == 1'b1 && a2d == 1'b0) begin 
	       next_state = done;
	       en = 1'b1;
	       snt = 1'b0;		       
	    end else if(vi == 1'b0 || a2d == 1'b1) begin
	       next_state = wdata;
	       en = 1'b1;
	       snt = 1'b0;
	 end

	 done: begin
	       next_state = wack;
	       en = 1'b0;
	       snt = 1'b1;	    	    
	 end

	 wack: begin
	    if(a2p == 1'b1) begin
	       next_state = wdata;
	       en = 1'b0;
	       snt = 1'b0;	
	    end else if(a2p == 1'b0) begin
	       next_state = wack;
	       en = 1'b0;
	       snt = 1'b0;
	    end	    
	 end
	
	 default: begin
	    next_state = wdata;
	    en = 1'b0;
	    snt = 1'b0	    
	 end	
      endcase // case (current_state)
   end // always @ (*)

endmodule // txfsm
